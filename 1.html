<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2575.7">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; -webkit-text-stroke: #000000}
    span.s1 {font-kerning: none}
    span.s2 {font: 13.0px Courier; font-kerning: none}
  </style>
</head>
<body>
<p class="p1"><span class="s1">&lt;!doctype html&gt; &lt;html lang="es"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1" /&gt; &lt;title&gt;MVP - Simulador 3D de Inspección Vehicular (UNES) — Mejorado&lt;/title&gt; &lt;!-- Tailwind CDN --&gt; &lt;script src="https://cdn.tailwindcss.com"&gt;&lt;/script&gt; &lt;!-- Three.js core + examples (OrbitControls + GLTFLoader) --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"&gt;&lt;/script&gt; &lt;style&gt; body { margin: 0; height: 100vh; background: #071028; color: #e6eef8; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; } #app { height: 100vh; display: flex; } #scene-container { flex: 1; position: relative; overflow: hidden; } canvas { display:block; width: 100%; height: 100%; } .glass { background: rgba(15,23,42,0.64); backdrop-filter: blur(6px); } .tooltip { position: absolute; transform: translate(-50%, -100%); pointer-events: none; white-space: nowrap; } .tooltip .inner { padding: .35rem .5rem; border-radius: .375rem; background: rgba(2,6,23,0.88); color: #e6eef8; font-size: .8rem; box-shadow: 0 6px 18px rgba(2,6,23,0.5); } .mode-badge { font-size: .7rem; padding: .18rem .4rem; border-radius: .375rem; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;div id="scene-container"&gt; &lt;div class="absolute top-4 left-4 z-30"&gt; &lt;div class="glass p-3 rounded-lg shadow-lg text-sm"&gt; &lt;div class="flex items-center gap-2"&gt; &lt;div class="font-semibold"&gt;MVP — Inspección Vehicular (UNES)&lt;/div&gt; &lt;div id="model-status" class="ml-2 mode-badge bg-yellow-600/90 rounded text-white px-2"&gt;Cargando modelo...&lt;/div&gt; &lt;/div&gt; &lt;div class="text-xs text-slate-300 mt-1"&gt;Rotar: arrastrar • Zoom: rueda • Click: seleccionar marcador&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Legend --&gt; &lt;div class="absolute bottom-4 left-4 z-30"&gt; &lt;div class="glass p-3 rounded-lg shadow-lg text-xs text-slate-200"&gt; &lt;div class="flex items-center gap-3"&gt; &lt;div&gt;&lt;span class="inline-block w-3 h-3 rounded-full bg-red-500 mr-2 align-middle"&gt;&lt;/span&gt; Sin inspeccionar&lt;/div&gt; &lt;div&gt;&lt;span class="inline-block w-3 h-3 rounded-full bg-blue-500 mr-2 align-middle"&gt;&lt;/span&gt; Seleccionada&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;aside class="w-96 p-6 glass"&gt; &lt;h2 class="text-2xl font-semibold mb-2"&gt;Panel de Protocolo&lt;/h2&gt; &lt;p class="text-sm text-slate-300 mb-4"&gt;Selecciona una zona en la escena 3D para ver el protocolo forense.&lt;/p&gt; &lt;div id="protocol-card" class="p-4 rounded-lg bg-slate-900/40"&gt; &lt;div id="point-label" class="text-xs text-slate-300"&gt;PUNTO&lt;/div&gt; &lt;h3 id="point-title" class="text-xl font-bold mt-2"&gt;—&lt;/h3&gt; &lt;p id="point-protocol" class="mt-3 text-sm text-slate-200 leading-relaxed"&gt;Selecciona un marcador en la escena.&lt;/p&gt; &lt;/div&gt; &lt;div class="mt-6"&gt; &lt;h4 class="text-sm text-slate-300 mb-2"&gt;Zonas&lt;/h4&gt; &lt;ul id="zone-list" class="space-y-2 text-sm"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div class="mt-6 flex gap-2"&gt; &lt;button id="reset-view" class="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600"&gt;Recentrar cámara&lt;/button&gt; &lt;button id="reset-selection" class="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600"&gt;Reset selección&lt;/button&gt; &lt;button id="toggle-model" class="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600"&gt;Forzar modelo local&lt;/button&gt; &lt;/div&gt; &lt;details class="mt-6 text-sm text-slate-300"&gt; &lt;summary class="cursor-pointer"&gt;Despliegue en GitHub Pages — Instrucciones&lt;/summary&gt; &lt;div class="mt-3"&gt; &lt;ol class="list-decimal pl-5 space-y-1"&gt; &lt;li&gt;Crear un repositorio en GitHub (por ejemplo: &lt;code&gt;mvp-inspeccion-3d&lt;/code&gt;).&lt;/li&gt; &lt;li&gt;Subir este archivo &lt;code&gt;index.html&lt;/code&gt; a la raíz del repositorio.&lt;/li&gt; &lt;li&gt;En Settings → Pages, seleccionar &lt;strong&gt;Branch: main&lt;/strong&gt; y carpeta &lt;strong&gt;/ (root)&lt;/strong&gt;. Guardar.&lt;/li&gt; &lt;li&gt;GitHub publicará la página en unos minutos en &lt;code&gt;https://&amp;lt;usuario&amp;gt;.github.io/&amp;lt;repo&amp;gt;/&lt;/code&gt;.&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;/details&gt; &lt;/aside&gt; &lt;/div&gt; &lt;!-- Tooltips container --&gt; &lt;div id="tooltips-root" style="position:fixed; left:0; top:0; pointer-events:none; width:100%; height:100%; z-index:50;"&gt;&lt;/div&gt; &lt;script&gt; /* ============================ Datos incrustados (5 zonas) ============================ */ const ZONES = [ { id: 1, label: 'Neumáticos y Suspensión', protocol: 'Inspeccionar el interior del guardabarros en busca de compartimentos ocultos. Verificar el desgaste irregular y el serial del neumático.' }, { id: 2, label: 'Compartimento del Motor', protocol: 'Revisar el cortafuegos por soldaduras recientes. Buscar cableado no original que indique dispositivos de rastreo o activación.' }, { id: 3, label: 'Maleta y Tanque', protocol: 'Golpear ligeramente la superficie para detectar doble fondo. Revisar el compartimento de la rueda de repuesto.' }, { id: 4, label: 'Tren Trasero y Ejes', protocol: 'Buscar evidencia trazológica (tierra, vegetación) que vincule el vehículo a una ubicación específica. Inspeccionar el chasis bajo el vehículo.' }, { id: 5, label: 'Interior y Paneles', protocol: 'Palpar asientos y paneles para bultos inusuales. Prestar atención al área bajo la alfombra y documentos en la guantera.' } ]; /* ============================ Escena, cámara, renderer ============================ */ const container = document.getElementById('scene-container'); const tooltipRoot = document.getElementById('tooltips-root'); const modelStatusEl = document.getElementById('model-status'); const scene = new THREE.Scene(); scene.background = new THREE.Color(0x071028); const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000); camera.position.set(6, 4, 8); const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false }); renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(container.clientWidth, container.clientHeight); container.appendChild(renderer.domElement); const hemi = new THREE.HemisphereLight(0xfff8ea, 0x0f1a2b, 0.8); scene.add(hemi); const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(5,10,7); scene.add(dir); const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({ color:0x081023, metalness:0.1, roughness:1 })); ground.rotation.x = -Math.PI/2; ground.position.y = -1.2; scene.add(ground); const controls = new THREE.OrbitControls(camera, renderer.domElement); controls.target.set(0, 0.6, 0); controls.enableDamping = true; controls.dampingFactor = 0.08; controls.minDistance = 2.5; controls.maxDistance = 25; controls.maxPolarAngle = Math.PI * 0.92; const raycaster = new THREE.Raycaster(); const pointer = new THREE.Vector2(); // Markers &amp; tooltips const markers = []; // { mesh, group, zone, tooltipDiv } let selectedMarker = null; let modelRoot = null; // loaded model (glTF) or fallback car // Default positions (relative to our fallback car geometry) const DEFAULT_POSITIONS = { 1: new THREE.Vector3(-1.4, 0.05, -0.95), // front-left tire 2: new THREE.Vector3(-1.65, 0.9, 0.0), // hood 3: new THREE.Vector3(1.6, 0.8, 0.0), // trunk/maletero 4: new THREE.Vector3(1.4, 0.05, -0.95), // rear-left tire 5: new THREE.Vector3(0.0, 1.2, 0.0) // roof/cabina }; // ============================ // Create fallback low-poly car // ============================ function createFallbackCar() { const car = new THREE.Group(); const chassisGeo = new THREE.BoxGeometry(4.2, 0.8, 2); const chassisMat = new THREE.MeshStandardMaterial({ color: 0x2b6cb0, metalness: 0.3, roughness: 0.5 }); const chassis = new THREE.Mesh(chassisGeo, chassisMat); chassis.position.y = 0.2; car.add(chassis); const cabinGeo = new THREE.BoxGeometry(2.5, 0.9, 1.6); const cabin = new THREE.Mesh(cabinGeo, new THREE.MeshStandardMaterial({ color:0x1e40af, metalness:0.25, roughness:0.4 })); cabin.position.set(0, 0.85, 0); car.add(cabin); const hood = new THREE.Mesh(new THREE.BoxGeometry(1.4,0.25,1.6), chassisMat); hood.position.set(-1.65, 0.45, 0); car.add(hood); const trunk = new THREE.Mesh(new THREE.BoxGeometry(1.0,0.25,1.6), chassisMat); trunk.position.set(1.6, 0.45, 0); car.add(trunk); const wheelGeo = new THREE.CylinderGeometry(0.4,0.4,0.5,12); const wheelMat = new THREE.MeshStandardMaterial({ color:0x111827, metalness:0.6, roughness:0.6 }); const wheelPositions = [ [-1.4, -0.15, -0.95], [1.4, -0.15, -0.95], [-1.4, -0.15, 0.95], [1.4, -0.15, 0.95] ]; wheelPositions.forEach(pos =&gt; { const wheel = new THREE.Mesh(wheelGeo, wheelMat); wheel.rotation.z = Math.PI / 2; wheel.position.set(pos[0], pos[1], pos[2]); car.add(wheel); }); const bumperMat = new THREE.MeshStandardMaterial({ color:0x0f172a, metalness:0.5, roughness:0.6 }); const frontBumper = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.3,1.6), bumperMat); frontBumper.position.set(-2.3, 0.2, 0); car.add(frontBumper); const rearBumper = frontBumper.clone(); rearBumper.position.set(2.35, 0.2, 0); car.add(rearBumper); car.position.set(0,0,0); return car; } // ============================ // Load external model (glTF) with fallback // ============================ // We'll attempt to load a vehicle sample from Khronos glTF sample models. // If it fails, usamos el fallback local. let forcedLocal = false; const GLTF_URL = 'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/CesiumMilkTruck/glTF/CesiumMilkTruck.gltf'; function loadModelFromCDN() { modelStatusEl.innerText = 'Cargando modelo desde CDN...'; modelStatusEl.className = 'ml-2 mode-badge bg-yellow-600/90 rounded text-white px-2'; const loader = new THREE.GLTFLoader(); loader.load(GLTF_URL, gltf =&gt; { // success modelRoot = gltf.scene; centerAndScaleModel(modelRoot); scene.add(modelRoot); modelStatusEl.innerText = 'Modelo CDN cargado'; modelStatusEl.className = 'ml-2 mode-badge bg-green-600/90 rounded text-white px-2'; // after model present, setup markers relative to model bounding box setupMarkersRelativeToModel(); }, xhr =&gt; { // progress (optional) // console.log('cargando', (xhr.loaded / xhr.total * 100) + '%'); }, err =&gt; { console.warn('Falló carga glTF, usando fallback. Error:', err); modelStatusEl.innerText = 'Error cargando modelo → fallback local'; modelStatusEl.className = 'ml-2 mode-badge bg-red-600/90 rounded text-white px-2'; useFallbackCar(); } ); } function useFallbackCar() { if (modelRoot) { scene.remove(modelRoot); modelRoot = null; } modelRoot = createFallbackCar(); centerAndScaleModel(modelRoot); scene.add(modelRoot); modelStatusEl.innerText = 'Modelo local (fallback)'; modelStatusEl.className = 'ml-2 mode-badge bg-blue-600/90 rounded text-white px-2'; setupMarkersRelativeToModel(); } function centerAndScaleModel(obj) { // compute bounding box and scale to fit scene nicely const box = new THREE.Box3().setFromObject(obj); const size = new THREE.Vector3(); box.getSize(size); const maxDim = Math.max(size.x, size.y, size.z); if (maxDim &lt; 0.001) return; const desired = 3.5; // roughly car length scale const scale = desired / maxDim; obj.scale.setScalar(scale); // recompute box after scale box.setFromObject(obj); const center = new THREE.Vector3(); box.getCenter(center); obj.position.sub(center); // center at origin // lift slightly if model bottom is below y=0 box.setFromObject(obj); const minY = box.min.y; if (minY &lt; -0.5) { obj.position.y += Math.abs(minY) + 0.6; } else { obj.position.y += 0; // keep natural } } /* ============================ Markers creation &amp; tooltips ============================ */ function createMarkersForPositions(positionsMap) { // clear existing markers &amp; tooltips markers.forEach(m =&gt; { if (m.group) scene.remove(m.group); if (m.tooltipDiv) { m.tooltipDiv.remove(); } }); markers.length = 0; const markerGeo = new THREE.SphereGeometry(0.18, 16, 16); const baseMat = new THREE.MeshStandardMaterial({ color: 0xff4444, transparent:true, opacity:0.92, emissive:0x220000 }); const stalkGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.25, 8); const stalkMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness:0.2, roughness:0.7 }); ZONES.forEach(zone =&gt; { const mat = baseMat.clone(); const marker = new THREE.Mesh(markerGeo, mat); marker.name = </span><span class="s2">zone-${zone.id}</span><span class="s1">; marker.userData = { id: zone.id }; const pos = positionsMap[zone.id] ? positionsMap[zone.id].clone() : DEFAULT_POSITIONS[zone.id].clone(); marker.position.copy(pos); marker.position.y += 0.28; const base = new THREE.Mesh(new THREE.SphereGeometry(0.07, 8, 8), new THREE.MeshStandardMaterial({color:0x000000})); base.position.set(pos.x, pos.y + 0.1, pos.z); const stalk = new THREE.Mesh(stalkGeo, stalkMat); stalk.position.set(pos.x, pos.y + 0.15, pos.z); stalk.rotation.x = Math.PI / 2; const group = new THREE.Group(); group.add(marker); group.add(stalk); group.add(base); group.userData = { id: zone.id, label: zone.label }; marker.userData.floatOffset = Math.random() * Math.PI * 2; scene.add(group); // Create tooltip DIV const tooltipDiv = document.createElement('div'); tooltipDiv.className = 'tooltip'; tooltipDiv.style.zIndex = 100; tooltipDiv.innerHTML = </span><span class="s2">&lt;div class="inner"&gt;&lt;strong&gt;${zone.id}. ${zone.label}&lt;/strong&gt;&lt;/div&gt;</span><span class="s1">; tooltipRoot.appendChild(tooltipDiv); markers.push({ mesh: marker, group, zone, tooltipDiv }); }); } // For external models we compute approximate positions based on bbox extents function setupMarkersRelativeToModel() { // compute bounding box const box = new THREE.Box3().setFromObject(modelRoot); const size = new THREE.Vector3(); box.getSize(size); const center = new THREE.Vector3(); box.getCenter(center); // We'll compute positions relative to bbox: // front-left: x = -halfX*0.9, z = -halfZ*0.9, y = centerY - halfY*0.2 const halfX = size.x / 2, halfZ = size.z / 2, halfY = size.y / 2; const baseY = box.min.y; // bottom const positions = {}; positions[1] = new THREE.Vector3(center.x - halfX*0.75, baseY + 0.2 + halfY*0.1, center.z - halfZ*0.75); positions[2] = new THREE.Vector3(center.x - halfX*0.9, baseY + halfY*1.05, center.z); // hood/front positions[3] = new THREE.Vector3(center.x + halfX*0.9, baseY + halfY*0.9, center.z); // trunk positions[4] = new THREE.Vector3(center.x + halfX*0.6, baseY + 0.2 + halfY*0.1, center.z - halfZ*0.75); // rear-left-ish positions[5] = new THREE.Vector3(center.x, baseY + halfY*1.2, center.z); // roof createMarkersForPositions(positions); populateZoneList(); } // ============================ // Marker selection + camera Bézier // ============================ function updateMarkersAnimation(time) { markers.forEach(m =&gt; { const t = (time * 0.001) + (m.mesh.userData.floatOffset || 0); const delta = Math.sin(t) * 0.003; m.mesh.position.y += delta; m.mesh.material.emissiveIntensity = 0.08 + Math.abs(Math.sin(t)) * 0.08; }); } function onPointerDown(event) { const rect = renderer.domElement.getBoundingClientRect(); pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(pointer, camera); const allMarkerMeshes = markers.map(m =&gt; m.mesh); const intersects = raycaster.intersectObjects(allMarkerMeshes, false); if (intersects.length &gt; 0) { const picked = intersects[0].object; const markerObj = markers.find(m =&gt; m.mesh === picked); if (markerObj) selectMarker(markerObj); } } // Cubic Bézier interpolation for camera path function cubicBezier(p0, p1, p2, p3, t) { const u = 1 - t; const tt = t*t; const uu = u*u; const uuu = uu * u; const ttt = tt * t; const res = new THREE.Vector3(); res.copy(p0).multiplyScalar(uuu) .add(new THREE.Vector3().copy(p1).multiplyScalar(3 * uu * t)) .add(new THREE.Vector3().copy(p2).multiplyScalar(3 * u * tt)) .add(new THREE.Vector3().copy(p3).multiplyScalar(ttt)); return res; } let cameraAnimation = null; function animateCameraTo(targetPos, targetLookAt, duration = 1000) { if (cameraAnimation) cameraAnimation.cancelled = true; const startPos = camera.position.clone(); const startTarget = controls.target.clone(); // control points: create two points offset from start/target to create smooth arc const dirA = new THREE.Vector3().subVectors(startPos, startTarget).normalize(); const dirB = new THREE.Vector3().subVectors(targetPos, targetLookAt).normalize(); const distance = startPos.distanceTo(targetPos); // control points distance scales const cpDist = THREE.MathUtils.clamp(distance * 0.6, 1.0, 6.0); const p0 = startPos.clone(); const p3 = targetPos.clone(); const p1 = startPos.clone().add(dirA.multiplyScalar(cpDist)).add(new THREE.Vector3(0, cpDist*0.25, 0)); const p2 = targetPos.clone().add(dirB.multiplyScalar(cpDist)).add(new THREE.Vector3(0, cpDist*0.25, 0)); const t0 = performance.now(); const tEnd = t0 + duration; cameraAnimation = { cancelled: false }; function step(now) { if (cameraAnimation.cancelled) return; const tt = Math.min(1, (now - t0) / duration); // ease in-out cubic const ease = tt &lt; 0.5 ? 4*tt*tt*tt : 1 - Math.pow(-2*tt + 2, 3)/2; const pos = cubicBezier(p0,p1,p2,p3, ease); camera.position.copy(pos); // interpolate lookAt linearly but with same ease const newTarget = new THREE.Vector3().lerpVectors(startTarget, targetLookAt, ease); controls.target.copy(newTarget); controls.update(); if (now &lt; tEnd) { requestAnimationFrame(step); } else { camera.position.copy(p3); controls.target.copy(targetLookAt); controls.update(); cameraAnimation = null; } } requestAnimationFrame(step); } function selectMarker(markerObj) { if (selectedMarker &amp;&amp; selectedMarker !== markerObj) { // revert color selectedMarker.mesh.material.color.set(0xff4444); selectedMarker.mesh.material.opacity = 0.92; } markerObj.mesh.material.color.set(0x3b82f6); markerObj.mesh.material.opacity = 1.0; selectedMarker = markerObj; // compute world position of marker const worldPos = new THREE.Vector3(); markerObj.mesh.getWorldPosition(worldPos); // desired camera position: offset from the marker along vector from model center to camera const center = new THREE.Vector3(); new THREE.Box3().setFromObject(modelRoot || scene).getCenter(center); const offsetDir = new THREE.Vector3().subVectors(camera.position, worldPos).normalize(); const desiredPos = worldPos.clone().add(offsetDir.multiplyScalar(2.8)).add(new THREE.Vector3(0,0.6,0)); const desiredTarget = worldPos.clone(); animateCameraTo(desiredPos, desiredTarget, 1100); updateProtocolPanel(markerObj.zone); } function resetSelection() { if (selectedMarker) { selectedMarker.mesh.material.color.set(0xff4444); selectedMarker.mesh.material.opacity = 0.92; selectedMarker = null; } document.getElementById('point-label').innerText = 'PUNTO'; document.getElementById('point-title').innerText = '—'; document.getElementById('point-protocol').innerText = 'Selecciona un marcador en la escena.'; // clear list highlight document.querySelectorAll('#zone-list li').forEach(li =&gt; li.classList.remove('bg-slate-800/60','rounded','p-2')); } function populateZoneList() { const ul = document.getElementById('zone-list'); ul.innerHTML = ''; ZONES.forEach(z =&gt; { const li = document.createElement('li'); li.className = 'flex justify-between items-start'; li.dataset.id = z.id; li.innerHTML = &lt;div&gt; &lt;div class="font-medium"&gt;${z.id}. ${z.label}&lt;/div&gt; &lt;div class="text-xs text-slate-400"&gt;${z.protocol.substring(0, 80)}${z.protocol.length&gt;80?'...':''}&lt;/div&gt; &lt;/div&gt; &lt;div class="ml-4"&gt; &lt;button class="inspect-btn inline-block px-2 py-1 text-xs rounded bg-slate-700 hover:bg-slate-600"&gt;Inspeccionar&lt;/button&gt; &lt;/div&gt; </span><span class="s2">; </span><span class="s1">ul.appendChild(li); li.querySelector('.inspect-btn').addEventListener('click', () =&gt; { const markerObj = markers.find(m =&gt; m.zone.id === z.id); if (markerObj) selectMarker(markerObj); }); }); } function updateProtocolPanel(zone) { document.getElementById('point-label').innerText = </span><span class="s2">PUNTO ${zone.id}</span><span class="s1">; document.getElementById('point-title').innerText = zone.label; document.getElementById('point-protocol').innerText = zone.protocol; document.querySelectorAll('#zone-list li').forEach(li =&gt; { if (li.dataset.id == zone.id) { li.classList.add('bg-slate-800/60','rounded','p-2'); } else { li.classList.remove('bg-slate-800/60','rounded','p-2'); } }); } /* ============================ Tooltip positioning (project world -&gt; screen) ============================ */ function updateTooltips() { const canvasRect = renderer.domElement.getBoundingClientRect(); markers.forEach(m =&gt; { const screenPos = m.mesh.position.clone(); m.mesh.getWorldPosition(screenPos); screenPos.project(camera); const x = (screenPos.x * 0.5 + 0.5) * canvasRect.width + canvasRect.left; const y = (-screenPos.y * 0.5 + 0.5) * canvasRect.height + canvasRect.top; m.tooltipDiv.style.left = </span><span class="s2">${x}px</span><span class="s1">; m.tooltipDiv.style.top = </span><span class="s2">${y - 12}px</span><span class="s1">; // hide if behind camera (z &gt; 1) if (screenPos.z &gt; 1) { m.tooltipDiv.style.display = 'none'; } else { m.tooltipDiv.style.display = ''; } }); } /* ============================ Events ============================ */ renderer.domElement.addEventListener('pointerdown', onPointerDown); window.addEventListener('resize', onWindowResize); document.getElementById('reset-view').addEventListener('click', () =&gt; { animateCameraTo(new THREE.Vector3(6,4,8), new THREE.Vector3(0,0.6,0), 900); }); document.getElementById('reset-selection').addEventListener('click', resetSelection); document.getElementById('toggle-model').addEventListener('click', () =&gt; { forcedLocal = !forcedLocal; if (forcedLocal) { modelStatusEl.innerText = 'Forzando modelo local'; modelStatusEl.className = 'ml-2 mode-badge bg-yellow-600/90 rounded text-white px-2'; // remove remote and add fallback if (modelRoot) scene.remove(modelRoot); useFallbackCar(); } else { // try reload remote if (modelRoot) scene.remove(modelRoot); loadModelFromCDN(); } }); function onWindowResize() { const w = container.clientWidth; const h = container.clientHeight; camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w, h); } /* ============================ Main loop ============================ */ function animate(time) { requestAnimationFrame(animate); const t = time || 0; updateMarkersAnimation(t); controls.update(); updateTooltips(); renderer.render(scene, camera); } // ============================ // Boot sequence: try load glTF, fallback if needed // ============================ (function boot() { // attempt to load remote model, fallback on error if (!forcedLocal) loadModelFromCDN(); else useFallbackCar(); // If modelLoad doesn't call setupMarkers (e.g., slow), ensure fallback markers after 1.5s setTimeout(() =&gt; { if (markers.length === 0 &amp;&amp; !modelRoot) useFallbackCar(); }, 1500); animate(); })(); // Prevent right-click renderer.domElement.addEventListener('contextmenu', e =&gt; e.preventDefault()); // Expose some helpers to console for debugging window.__mvp = { scene, camera, renderer, controls, markers, modelRoot, reloadRemote: () =&gt; { if (modelRoot) scene.remove(modelRoot); loadModelFromCDN(); } }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</span></p>
</body>
</html>
